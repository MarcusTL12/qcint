// This function is ported from libslater library
// https://github.com/nubakery/libslater

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "simd.h"
#include "rys_roots.h"
#include "roots_xw.dat"

/*
from mpmath import *
mp.dps = 25
for i in range(14):
    for j in range(14):
        print ' %.19e' % cos(pi*j*(2*i+1)/28)
*/
static const double COS_14_14[] = {
 1.                       ,
 9.9371220989324260398e-01,
 9.7492791218182361934e-01,
 9.4388333030836757409e-01,
 9.0096886790241914600e-01,
 8.4672419922828412453e-01,
 7.8183148246802980363e-01,
 7.0710678118654757274e-01,
 6.2348980185873348336e-01,
 5.3203207651533657163e-01,
 4.3388373911755812040e-01,
 3.3027906195516709698e-01,
 2.2252093395631439288e-01,
 1.1196447610330785560e-01,
 1.                       ,
 9.4388333030836757409e-01,
 7.8183148246802980363e-01,
 5.3203207651533657163e-01,
 2.2252093395631439288e-01,
-1.1196447610330785560e-01,
-4.3388373911755812040e-01,
-7.0710678118654757274e-01,
-9.0096886790241914600e-01,
-9.9371220989324260398e-01,
-9.7492791218182361934e-01,
-8.4672419922828412453e-01,
-6.2348980185873348336e-01,
-3.3027906195516709698e-01,
 1.                       ,
 8.4672419922828412453e-01,
 4.3388373911755812040e-01,
-1.1196447610330785560e-01,
-6.2348980185873348336e-01,
-9.4388333030836757409e-01,
-9.7492791218182361934e-01,
-7.0710678118654757274e-01,
-2.2252093395631439288e-01,
 3.3027906195516709698e-01,
 7.8183148246802980363e-01,
 9.9371220989324260398e-01,
 9.0096886790241914600e-01,
 5.3203207651533657163e-01,
 1.                       ,
 7.0710678118654757274e-01,
 0.                       ,
-7.0710678118654757274e-01,
-1.                       ,
-7.0710678118654757274e-01,
 0.                       ,
 7.0710678118654757274e-01,
 1.                       ,
 7.0710678118654757274e-01,
 0.                       ,
-7.0710678118654757274e-01,
-1.                       ,
-7.0710678118654757274e-01,
 1.                       ,
 5.3203207651533657163e-01,
-4.3388373911755812040e-01,
-9.9371220989324260398e-01,
-6.2348980185873348336e-01,
 3.3027906195516709698e-01,
 9.7492791218182361934e-01,
 7.0710678118654757274e-01,
-2.2252093395631439288e-01,
-9.4388333030836757409e-01,
-7.8183148246802980363e-01,
 1.1196447610330785560e-01,
 9.0096886790241914600e-01,
 8.4672419922828412453e-01,
 1.                       ,
 3.3027906195516709698e-01,
-7.8183148246802980363e-01,
-8.4672419922828412453e-01,
 2.2252093395631439288e-01,
 9.9371220989324260398e-01,
 4.3388373911755812040e-01,
-7.0710678118654757274e-01,
-9.0096886790241914600e-01,
 1.1196447610330785560e-01,
 9.7492791218182361934e-01,
 5.3203207651533657163e-01,
-6.2348980185873348336e-01,
-9.4388333030836757409e-01,
 1.                       ,
 1.1196447610330785560e-01,
-9.7492791218182361934e-01,
-3.3027906195516709698e-01,
 9.0096886790241914600e-01,
 5.3203207651533657163e-01,
-7.8183148246802980363e-01,
-7.0710678118654757274e-01,
 6.2348980185873348336e-01,
 8.4672419922828412453e-01,
-4.3388373911755812040e-01,
-9.4388333030836757409e-01,
 2.2252093395631439288e-01,
 9.9371220989324260398e-01,
 1.                       ,
-1.1196447610330785560e-01,
-9.7492791218182361934e-01,
 3.3027906195516709698e-01,
 9.0096886790241914600e-01,
-5.3203207651533657163e-01,
-7.8183148246802980363e-01,
 7.0710678118654757274e-01,
 6.2348980185873348336e-01,
-8.4672419922828412453e-01,
-4.3388373911755812040e-01,
 9.4388333030836757409e-01,
 2.2252093395631439288e-01,
-9.9371220989324260398e-01,
 1.                       ,
-3.3027906195516709698e-01,
-7.8183148246802980363e-01,
 8.4672419922828412453e-01,
 2.2252093395631439288e-01,
-9.9371220989324260398e-01,
 4.3388373911755812040e-01,
 7.0710678118654757274e-01,
-9.0096886790241914600e-01,
-1.1196447610330785560e-01,
 9.7492791218182361934e-01,
-5.3203207651533657163e-01,
-6.2348980185873348336e-01,
 9.4388333030836757409e-01,
 1.                       ,
-5.3203207651533657163e-01,
-4.3388373911755812040e-01,
 9.9371220989324260398e-01,
-6.2348980185873348336e-01,
-3.3027906195516709698e-01,
 9.7492791218182361934e-01,
-7.0710678118654757274e-01,
-2.2252093395631439288e-01,
 9.4388333030836757409e-01,
-7.8183148246802980363e-01,
-1.1196447610330785560e-01,
 9.0096886790241914600e-01,
-8.4672419922828412453e-01,
 1.                       ,
-7.0710678118654757274e-01,
 0.                       ,
 7.0710678118654757274e-01,
-1.                       ,
 7.0710678118654757274e-01,
 0.                       ,
-7.0710678118654757274e-01,
 1.                       ,
-7.0710678118654757274e-01,
 0.                       ,
 7.0710678118654757274e-01,
-1.                       ,
 7.0710678118654757274e-01,
 1.                       ,
-8.4672419922828412453e-01,
 4.3388373911755812040e-01,
 1.1196447610330785560e-01,
-6.2348980185873348336e-01,
 9.4388333030836757409e-01,
-9.7492791218182361934e-01,
 7.0710678118654757274e-01,
-2.2252093395631439288e-01,
-3.3027906195516709698e-01,
 7.8183148246802980363e-01,
-9.9371220989324260398e-01,
 9.0096886790241914600e-01,
-5.3203207651533657163e-01,
 1.                       ,
-9.4388333030836757409e-01,
 7.8183148246802980363e-01,
-5.3203207651533657163e-01,
 2.2252093395631439288e-01,
 1.1196447610330785560e-01,
-4.3388373911755812040e-01,
 7.0710678118654757274e-01,
-9.0096886790241914600e-01,
 9.9371220989324260398e-01,
-9.7492791218182361934e-01,
 8.4672419922828412453e-01,
-6.2348980185873348336e-01,
 3.3027906195516709698e-01,
 1.                       ,
-9.9371220989324260398e-01,
 9.7492791218182361934e-01,
-9.4388333030836757409e-01,
 9.0096886790241914600e-01,
-8.4672419922828412453e-01,
 7.8183148246802980363e-01,
-7.0710678118654757274e-01,
 6.2348980185873348336e-01,
-5.3203207651533657163e-01,
 4.3388373911755812040e-01,
-3.3027906195516709698e-01,
 2.2252093395631439288e-01,
-1.1196447610330785560e-01,
};

static void _clenshaw_dc(double *rr, const double *x, double u, int nroot)
{
    double d[14];
    double g[14];
    double u2 = u * 2.;
    int i, k;

    for (i = 0; i < nroot; ++i) {
        d[0 ] = 0; g[0 ] = x[13+14*0 ];
        d[1 ] = 0; g[1 ] = x[13+14*1 ];
        d[2 ] = 0; g[2 ] = x[13+14*2 ];
        d[3 ] = 0; g[3 ] = x[13+14*3 ];
        for (k = 11; k >= 1; k-=2) {
            d[0 ] = u2 * g[0 ] - d[0 ] + x[k+1+0 *14];
            d[1 ] = u2 * g[1 ] - d[1 ] + x[k+1+1 *14];
            d[2 ] = u2 * g[2 ] - d[2 ] + x[k+1+2 *14];
            d[3 ] = u2 * g[3 ] - d[3 ] + x[k+1+3 *14];
            g[0 ] = u2 * d[0 ] - g[0 ] + x[k+  0 *14];
            g[1 ] = u2 * d[1 ] - g[1 ] + x[k+  1 *14];
            g[2 ] = u2 * d[2 ] - g[2 ] + x[k+  2 *14];
            g[3 ] = u2 * d[3 ] - g[3 ] + x[k+  3 *14];
        }
        rr[SIMDD*(0+14*i)] = u * g[0 ] - d[0 ] + x[0 *14] * 0.5;
        rr[SIMDD*(1+14*i)] = u * g[1 ] - d[1 ] + x[1 *14] * 0.5;
        rr[SIMDD*(2+14*i)] = u * g[2 ] - d[2 ] + x[2 *14] * 0.5;
        rr[SIMDD*(3+14*i)] = u * g[3 ] - d[3 ] + x[3 *14] * 0.5;

        d[4 ] = 0; g[4 ] = x[13+14*4 ];
        d[5 ] = 0; g[5 ] = x[13+14*5 ];
        d[6 ] = 0; g[6 ] = x[13+14*6 ];
        d[7 ] = 0; g[7 ] = x[13+14*7 ];
        for (k = 11; k >= 1; k-=2) {
            d[4 ] = u2 * g[4 ] - d[4 ] + x[k+1+4 *14];
            d[5 ] = u2 * g[5 ] - d[5 ] + x[k+1+5 *14];
            d[6 ] = u2 * g[6 ] - d[6 ] + x[k+1+6 *14];
            d[7 ] = u2 * g[7 ] - d[7 ] + x[k+1+7 *14];
            g[4 ] = u2 * d[4 ] - g[4 ] + x[k+  4 *14];
            g[5 ] = u2 * d[5 ] - g[5 ] + x[k+  5 *14];
            g[6 ] = u2 * d[6 ] - g[6 ] + x[k+  6 *14];
            g[7 ] = u2 * d[7 ] - g[7 ] + x[k+  7 *14];
        }
        rr[SIMDD*(4+14*i)] = u * g[4 ] - d[4 ] + x[4 *14] * 0.5;
        rr[SIMDD*(5+14*i)] = u * g[5 ] - d[5 ] + x[5 *14] * 0.5;
        rr[SIMDD*(6+14*i)] = u * g[6 ] - d[6 ] + x[6 *14] * 0.5;
        rr[SIMDD*(7+14*i)] = u * g[7 ] - d[7 ] + x[7 *14] * 0.5;

        d[8 ] = 0; g[8 ] = x[13+14*8 ];
        d[9 ] = 0; g[9 ] = x[13+14*9 ];
        d[10] = 0; g[10] = x[13+14*10];
        d[11] = 0; g[11] = x[13+14*11];
        d[12] = 0; g[12] = x[13+14*12];
        d[13] = 0; g[13] = x[13+14*13];
        for (k = 11; k >= 1; k-=2) {
            d[8 ] = u2 * g[8 ] - d[8 ] + x[k+1+8 *14];
            d[9 ] = u2 * g[9 ] - d[9 ] + x[k+1+9 *14];
            d[10] = u2 * g[10] - d[10] + x[k+1+10*14];
            d[11] = u2 * g[11] - d[11] + x[k+1+11*14];
            d[12] = u2 * g[12] - d[12] + x[k+1+12*14];
            d[13] = u2 * g[13] - d[13] + x[k+1+13*14];
            g[8 ] = u2 * d[8 ] - g[8 ] + x[k+  8 *14];
            g[9 ] = u2 * d[9 ] - g[9 ] + x[k+  9 *14];
            g[10] = u2 * d[10] - g[10] + x[k+  10*14];
            g[11] = u2 * d[11] - g[11] + x[k+  11*14];
            g[12] = u2 * d[12] - g[12] + x[k+  12*14];
            g[13] = u2 * d[13] - g[13] + x[k+  13*14];
        }
        rr[SIMDD*(8 +14*i)] = u * g[8 ] - d[8 ] + x[8 *14] * 0.5;
        rr[SIMDD*(9 +14*i)] = u * g[9 ] - d[9 ] + x[9 *14] * 0.5;
        rr[SIMDD*(10+14*i)] = u * g[10] - d[10] + x[10*14] * 0.5;
        rr[SIMDD*(11+14*i)] = u * g[11] - d[11] + x[11*14] * 0.5;
        rr[SIMDD*(12+14*i)] = u * g[12] - d[12] + x[12*14] * 0.5;
        rr[SIMDD*(13+14*i)] = u * g[13] - d[13] + x[13*14] * 0.5;

        x += 196;
    }
}

static void _clenshaw_d1(double *rr, const double *x, double *u, int nroot)
{
    int i;
    __MD d0, d1, g0, g1;
    __MD u2 = MM_SET1(2.) * MM_LOAD(u);

    for (i = 0; i < nroot-1; i+=2) {
        d0 = MM_SET1(0.);
        d1 = MM_SET1(0.);
        g0 = MM_LOAD(x+SIMDD*(13+   14*i));
        g1 = MM_LOAD(x+SIMDD*(13+14+14*i));
        d0 = u2 * g0 - d0 + MM_LOAD(x+SIMDD*(12+   14*i));
        d1 = u2 * g1 - d1 + MM_LOAD(x+SIMDD*(12+14+14*i));
        g0 = u2 * d0 - g0 + MM_LOAD(x+SIMDD*(11+   14*i));
        g1 = u2 * d1 - g1 + MM_LOAD(x+SIMDD*(11+14+14*i));
        d0 = u2 * g0 - d0 + MM_LOAD(x+SIMDD*(10+   14*i));
        d1 = u2 * g1 - d1 + MM_LOAD(x+SIMDD*(10+14+14*i));
        g0 = u2 * d0 - g0 + MM_LOAD(x+SIMDD*(9 +   14*i));
        g1 = u2 * d1 - g1 + MM_LOAD(x+SIMDD*(9 +14+14*i));
        d0 = u2 * g0 - d0 + MM_LOAD(x+SIMDD*(8 +   14*i));
        d1 = u2 * g1 - d1 + MM_LOAD(x+SIMDD*(8 +14+14*i));
        g0 = u2 * d0 - g0 + MM_LOAD(x+SIMDD*(7 +   14*i));
        g1 = u2 * d1 - g1 + MM_LOAD(x+SIMDD*(7 +14+14*i));
        d0 = u2 * g0 - d0 + MM_LOAD(x+SIMDD*(6 +   14*i));
        d1 = u2 * g1 - d1 + MM_LOAD(x+SIMDD*(6 +14+14*i));
        g0 = u2 * d0 - g0 + MM_LOAD(x+SIMDD*(5 +   14*i));
        g1 = u2 * d1 - g1 + MM_LOAD(x+SIMDD*(5 +14+14*i));
        d0 = u2 * g0 - d0 + MM_LOAD(x+SIMDD*(4 +   14*i));
        d1 = u2 * g1 - d1 + MM_LOAD(x+SIMDD*(4 +14+14*i));
        g0 = u2 * d0 - g0 + MM_LOAD(x+SIMDD*(3 +   14*i));
        g1 = u2 * d1 - g1 + MM_LOAD(x+SIMDD*(3 +14+14*i));
        d0 = u2 * g0 - d0 + MM_LOAD(x+SIMDD*(2 +   14*i));
        d1 = u2 * g1 - d1 + MM_LOAD(x+SIMDD*(2 +14+14*i));
        g0 = u2 * d0 - g0 + MM_LOAD(x+SIMDD*(1 +   14*i));
        g1 = u2 * d1 - g1 + MM_LOAD(x+SIMDD*(1 +14+14*i));
        MM_STORE(rr+SIMDD*(i  ), MM_LOAD(u) * g0 - d0 + MM_LOAD(x+SIMDD*(14*i   )) * MM_SET1(0.5));
        MM_STORE(rr+SIMDD*(i+1), MM_LOAD(u) * g1 - d1 + MM_LOAD(x+SIMDD*(14*i+14)) * MM_SET1(0.5));
    }
    if (i < nroot) {
        d0 = MM_SET1(0.);
        g0 = MM_LOAD(x+SIMDD*(13+14*i));
        d0 = u2 * g0 - d0 + MM_LOAD(x+SIMDD*(12+14*i));
        g0 = u2 * d0 - g0 + MM_LOAD(x+SIMDD*(11+14*i));
        d0 = u2 * g0 - d0 + MM_LOAD(x+SIMDD*(10+14*i));
        g0 = u2 * d0 - g0 + MM_LOAD(x+SIMDD*(9 +14*i));
        d0 = u2 * g0 - d0 + MM_LOAD(x+SIMDD*(8 +14*i));
        g0 = u2 * d0 - g0 + MM_LOAD(x+SIMDD*(7 +14*i));
        d0 = u2 * g0 - d0 + MM_LOAD(x+SIMDD*(6 +14*i));
        g0 = u2 * d0 - g0 + MM_LOAD(x+SIMDD*(5 +14*i));
        d0 = u2 * g0 - d0 + MM_LOAD(x+SIMDD*(4 +14*i));
        g0 = u2 * d0 - g0 + MM_LOAD(x+SIMDD*(3 +14*i));
        d0 = u2 * g0 - d0 + MM_LOAD(x+SIMDD*(2 +14*i));
        g0 = u2 * d0 - g0 + MM_LOAD(x+SIMDD*(1 +14*i));
        MM_STORE(rr+SIMDD*i, MM_LOAD(u) * g0 - d0 + MM_LOAD(x+SIMDD*14*i) * MM_SET1(0.5));
    }
}

static void _matmul_14_14(double *imc, double *im, int nroot)
{
    __MD o7 = MM_SET1(0.14285714285714285714);
    __MD s0;
    __MD d0[14];
    int i, j;
    for (i = 0; i < nroot; i++) {
        d0[0 ] = MM_SET1(0.);
        d0[1 ] = MM_SET1(0.);
        d0[2 ] = MM_SET1(0.);
        d0[3 ] = MM_SET1(0.);
        d0[4 ] = MM_SET1(0.);
        d0[5 ] = MM_SET1(0.);
        d0[6 ] = MM_SET1(0.);
        d0[7 ] = MM_SET1(0.);
        d0[8 ] = MM_SET1(0.);
        d0[9 ] = MM_SET1(0.);
        d0[10] = MM_SET1(0.);
        d0[11] = MM_SET1(0.);
        d0[12] = MM_SET1(0.);
        d0[13] = MM_SET1(0.);
        for (j = 0; j < 14; j++) {
            s0 = MM_LOAD(im+SIMDD*(j+14*i));
            d0[0 ] += s0 * MM_SET1(COS_14_14[j*14+0 ]);
            d0[1 ] += s0 * MM_SET1(COS_14_14[j*14+1 ]);
            d0[2 ] += s0 * MM_SET1(COS_14_14[j*14+2 ]);
            d0[3 ] += s0 * MM_SET1(COS_14_14[j*14+3 ]);
            d0[4 ] += s0 * MM_SET1(COS_14_14[j*14+4 ]);
            d0[5 ] += s0 * MM_SET1(COS_14_14[j*14+5 ]);
            d0[6 ] += s0 * MM_SET1(COS_14_14[j*14+6 ]);
            d0[7 ] += s0 * MM_SET1(COS_14_14[j*14+7 ]);
            d0[8 ] += s0 * MM_SET1(COS_14_14[j*14+8 ]);
            d0[9 ] += s0 * MM_SET1(COS_14_14[j*14+9 ]);
            d0[10] += s0 * MM_SET1(COS_14_14[j*14+10]);
            d0[11] += s0 * MM_SET1(COS_14_14[j*14+11]);
            d0[12] += s0 * MM_SET1(COS_14_14[j*14+12]);
            d0[13] += s0 * MM_SET1(COS_14_14[j*14+13]);
        }
        MM_STORE(imc+SIMDD*(0 +14*i), o7 * d0[0 ]);
        MM_STORE(imc+SIMDD*(1 +14*i), o7 * d0[1 ]);
        MM_STORE(imc+SIMDD*(2 +14*i), o7 * d0[2 ]);
        MM_STORE(imc+SIMDD*(3 +14*i), o7 * d0[3 ]);
        MM_STORE(imc+SIMDD*(4 +14*i), o7 * d0[4 ]);
        MM_STORE(imc+SIMDD*(5 +14*i), o7 * d0[5 ]);
        MM_STORE(imc+SIMDD*(6 +14*i), o7 * d0[6 ]);
        MM_STORE(imc+SIMDD*(7 +14*i), o7 * d0[7 ]);
        MM_STORE(imc+SIMDD*(8 +14*i), o7 * d0[8 ]);
        MM_STORE(imc+SIMDD*(9 +14*i), o7 * d0[9 ]);
        MM_STORE(imc+SIMDD*(10+14*i), o7 * d0[10]);
        MM_STORE(imc+SIMDD*(11+14*i), o7 * d0[11]);
        MM_STORE(imc+SIMDD*(12+14*i), o7 * d0[12]);
        MM_STORE(imc+SIMDD*(13+14*i), o7 * d0[13]);
    }
}

static void _stg_roots_part(int nroots, double* ta, double* ua, double* rr, double* ww, int count)
{
  const double* x = DATA_X + (nroots-1)*nroots/2 * 19600;
  const double* w = DATA_W + (nroots-1)*nroots/2 * 19600;
  double u, uu, t, tt;
  int i, iu, it;
  int offset[SIMDD];
  double uu4[SIMDD];
  ALIGNMM double im [SIMDD*28*nroots];
  ALIGNMM double *imc = im + SIMDD * 14 * nroots;
  ALIGNMM double tt4[SIMDD];

  for (i = 0; i != count; ++i) {// loop over parameter set
      t = ta[i];
      if (t > 19682.99) t = 19682.99;
      u = ua[i];
      if (t > 1.0) {
          tt = log(t) * 0.9102392266268373 + 1.0; // log(3)+1 
      } else {
          tt = sqrt(t);
      }
      uu = log10(u);

      it = (int)tt;
      tt = tt - it;
      tt4[i] = 2.0 * tt - 1.0;

      iu = (uu + 7); // 0 <= iu <= 9
      if (iu < 0 || iu > 10) {
          fprintf(stderr, "current implementation assumes 1.0e-7 < U < 1.0e3");
          exit(1);
      } else {
          uu = uu - (iu - 7);
          uu4[i] = 2.0 * uu - 1.0;
      }
      offset[i] = nroots * 196 * (iu + it * 10);
  }

  for (i = 0; i != count; ++i) {
      _clenshaw_dc(im+i, x+offset[i], uu4[i], nroots);
  }
  _matmul_14_14(imc, im, nroots);
  _clenshaw_d1(rr, imc, tt4, nroots);
  for (i = 0; i != count; ++i) {
      _clenshaw_dc(im+i, w+offset[i], uu4[i], nroots);
  }
  _matmul_14_14(imc, im, nroots);
  _clenshaw_d1(ww, imc, tt4, nroots);
}

void _CINTstg_roots_batch(int nroots, double* ta, double* ua, double* rr, double* ww, int count)
{
        _stg_roots_part(nroots, ta, ua, rr, ww, count);
        //uu = 1./sqrt(ua[i]);
        __MD r0 = MM_DIV(MM_SET1(1.), MM_SQRT(MM_LOAD(ua)));
        int i;
        for (i = 0; i < nroots; i++) {
                MM_STORE(ww+i*SIMDD, MM_LOAD(ww+i*SIMDD) * r0);
        }
}

void CINTstg_roots(int nroots, double ta, double ua, double* rr, double* ww)
{
        ALIGNMM double rtmp[SIMDD * 32];
        ALIGNMM double *wtmp = rtmp + SIMDD * nroots;
        _stg_roots_part(nroots, &ta, &ua, rtmp, wtmp, 1);
        double uu = 1./sqrt(ua);
        int i;
        for (i = 0; i < nroots; i++) {
                rr[i] = rtmp[i * SIMDD];
                ww[i] = wtmp[i * SIMDD] * uu;
        }
}
